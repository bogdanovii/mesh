class Printer{
  private:
    TriDeSetka* setka;
    std::string vtkFilename;

    //идет ли запись сейчас
    bool isWriting_vtk;

    const bool print_VTK_header(const std::string vtkFilename){
      std::vector<std::string> zapis;
      //vtk DataFile Version
      zapis.push_back("# vtk DataFile Version 3.0");
      //info about data
      zapis.push_back("Generated by mfem-seismo");
      //The file format
      zapis.push_back("ASCII");
      //dataset structure
      zapis.push_back("DATASET UNSTRUCTURED_GRID");

      const bool res{writeFile(vtkFilename, zapis)};
      return res;
    }

    const bool print_VTK_yzly(const std::string vtkFilename){
      std::vector<std::string> zapis;

      zapis.push_back("POINTS " + std::to_string(setka->getNumber_of_Nodes()) + " double");

      for(int i = 0; i < setka->getNumber_of_Nodes(); i++){
        Coord_of_Node curYZL = setka->getC_of_N().at(i);
        const std::string x = std::to_string(curYZL.getX());
        const std::string y = std::to_string(curYZL.getY());
        const std::string z = std::to_string(curYZL.getZ());
        zapis.push_back(x + " " + y + " " + z);
      }

      const bool res{writeFile(vtkFilename, zapis)};
      return res;
    }

    const bool print_VTK_yacheyk(const std::string vtkFilename){
      std::vector<std::string> zapis;

      zapis.push_back("CELLS " + std::to_string(setka->getNumber_of_Cells()) + " " + std::to_string(9 * (setka->getNumber_of_Cells())));

      //надо пронумеровать все узлы, внимание, эта функция только для куба написа
      std::vector<Coord_of_Node> c_of_nZYX  = setka->getC_of_NZYX();


      std::vector<int> Nymera_of_NodesX;
      for(int x = 0; x < setka->getN_x(); x++){
        Nymera_of_NodesX.push_back(0);
      }

      std::vector<std::vector<int>> Nymera_of_NodesY;
      for(int y = 0; y < setka->getN_y(); y++){
        Nymera_of_NodesY.push_back(Nymera_of_NodesX);
      }
      std::vector<std::vector<std::vector<int>>> Nymera_of_NodesZ;
      for(int z = 0; z < setka->getN_z(); z++){
        Nymera_of_NodesZ.push_back(Nymera_of_NodesY);
      }

      int i = 0;
      for(int z = 0; z < setka->getN_z(); z++){
        for(int y = 0; y < setka->getN_y(); y++){
          for(int x = 0; x < setka->getN_x(); x++){
            Nymera_of_NodesZ.at(z).at(y).at(x) = i;
            i++;
          }
        }
      }

      for(int z = 0; z < (setka->getN_z() -1); z++){
        for(int y = 0; y < (setka->getN_y()-1); y++){
          for(int x = 0; x < (setka->getN_x() -1); x++){
            std::string temp = "8 ";
            //привели указатель на стартовую точку, далее объход
            temp += std::to_string(Nymera_of_NodesZ.at(z).at(y).at(x)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z).at(y).at(x+1)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z).at(y+1).at(x+1)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z).at(y+1).at(x)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z+1).at(y).at(x)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z+1).at(y).at(x+1)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z+1).at(y+1).at(x+1)) + " ";
            temp += std::to_string(Nymera_of_NodesZ.at(z+1).at(y+1).at(x)) + " ";
            zapis.push_back(temp);
          }
        }
      }
      zapis.push_back("CELL_TYPES " + std::to_string(setka->getNumber_of_Cells()));
      for (int i = 0; i < setka->getNumber_of_Cells(); i++){
        zapis.push_back("12");
      }
      zapis.push_back("CELL_DATA " + std::to_string(setka->getNumber_of_Cells()));
      zapis.push_back("SCALARS material int");
      zapis.push_back("LOOKUP_TABLE default");
      for (int i = 0; i < setka->getNumber_of_Cells(); i++){
        zapis.push_back("1");
      }
      const bool res{writeFile(vtkFilename, zapis)};
      return res;
    }


  public:

    Printer(TriDeSetka* setk){
      isWriting_vtk = false;
      this->setka = setk;
    }

    const bool print_Paralepip(const std::string filename){
      while(isWriting_vtk == true){
        sleep(1);
      }
      isWriting_vtk = true;
      vtkFilename = filename;
      std::vector<std::string> zapis;
      const bool r1 = reWriteFile(this->vtkFilename, zapis);
      const bool r2 = print_VTK_header(this->vtkFilename);
      const bool r3 = print_VTK_yzly(this->vtkFilename);
      const bool r4 = print_VTK_yacheyk(this->vtkFilename);

      //Вот эта функция ошибочная была, посмотри голубева и перепиши, чтобы , как у негорещзультат  лобхода давала
      //const bool r3 = print_VTK_yzly(this->vtkFilename);

      isWriting_vtk = false;
      return true;

    }
};
